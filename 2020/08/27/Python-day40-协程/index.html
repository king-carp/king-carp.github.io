<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python day40:协程 | 王寄鱼's Blog</title><meta name="description" content="一、线程池与进程池shutdown一般线程也不需要开太多，一条进程下开十个线程已经比较多了。在工作中一般不要开进程，除非你知道需要计算密集型。 主线程等待所有任务执行完成： 1234567891011121314151617181920from concurrent.futures import ThreadPoolExecutorimport timepool &#x3D; ThreadPoolExecu"><meta name="keywords" content="Python"><meta name="author" content="王寄鱼"><meta name="copyright" content="王寄鱼"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/27/Python-day40-%E5%8D%8F%E7%A8%8B/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="Python day40:协程"><meta property="og:url" content="http://yoursite.com/2020/08/27/Python-day40-%E5%8D%8F%E7%A8%8B/"><meta property="og:site_name" content="王寄鱼's Blog"><meta property="og:description" content="一、线程池与进程池shutdown一般线程也不需要开太多，一条进程下开十个线程已经比较多了。在工作中一般不要开进程，除非你知道需要计算密集型。 主线程等待所有任务执行完成： 1234567891011121314151617181920from concurrent.futures import ThreadPoolExecutorimport timepool &#x3D; ThreadPoolExecu"><meta property="og:image" content="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><meta property="article:published_time" content="2020-08-27T03:20:10.472Z"><meta property="article:modified_time" content="2020-08-29T01:53:21.889Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"limitCount":50,"languages":{"author":"作者: 王寄鱼","link":"链接: ","source":"来源: 王寄鱼's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公平,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-29 09:53:21'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://s1.ax1x.com/2020/07/26/aCcVVe.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B1%A0shutdown"><span class="toc-number">1.</span> <span class="toc-text">一、线程池与进程池shutdown</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二、定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程，线程，协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.</span> <span class="toc-text">协程介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">协程的优缺点（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81greenlet%E6%A8%A1%E5%9D%97%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">四、greenlet模块（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81gevent%E6%A8%A1%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">五、gevent模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81asyncio%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">六、asyncio（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81io%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">七、io模型（面试重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%93%8D%E4%BD%9C%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">IO操作本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">io模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9Eio%EF%BC%88BI-O%EF%BC%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">阻塞io（BI&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9Eio%EF%BC%88NI-O%EF%BC%89"><span class="toc-number">7.2.2.</span> <span class="toc-text">非阻塞io（NI&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-Multiplexing-I-O"><span class="toc-number">7.2.3.</span> <span class="toc-text">io多路复用(Multiplexing - I&#x2F;O)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%AD%E7%9A%84select-poll-epoll"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">关于多路复用中的select,poll,epoll</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5io%EF%BC%88AI-O%EF%BC%89"><span class="toc-number">7.2.4.</span> <span class="toc-text">异步io（AI&#x2F;O）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io"><span class="toc-number">7.2.5.</span> <span class="toc-text">信号驱动io</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5I-O%E4%B8%8E%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">7.3.</span> <span class="toc-text">同步I&#x2F;O与异步I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">8.</span> <span class="toc-text">八、并发-并行-同步-异步-阻塞-非阻塞</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/08/09/a7SlNt.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">王寄鱼's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Python day40:协程</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-27T03:20:10.472Z" title="发表于 2020-08-27 11:20:10">2020-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-29T01:53:21.889Z" title="更新于 2020-08-29 09:53:21">2020-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%AD%A6%E4%B9%A0/">Python学习</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="一、线程池与进程池shutdown"><a href="#一、线程池与进程池shutdown" class="headerlink" title="一、线程池与进程池shutdown"></a>一、线程池与进程池shutdown</h2><p>一般线程也不需要开太多，一条进程下开十个线程已经比较多了。在工作中一般不要开进程，除非你知道需要计算密集型。</p>
<p>主线程等待所有任务执行完成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s 开始&#x27;</span>%name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s 结束&#x27;</span>%name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        pool.submit(task, <span class="string">&#x27;屌丝%s&#x27;</span> % i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 放到for外面</span></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)  <span class="comment"># 等待所有任务完成，并且把池关闭</span></span><br><span class="line">    <span class="comment"># 问题，关了还能提交任务吗？不能再提交了</span></span><br><span class="line">    pool.submit(task,<span class="string">&#x27;sdddd&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;主&#x27;</span>) <span class="comment"># 立马执行，20个线程都执行完了，再执行</span></span><br></pre></td></tr></table></figure>

<h2 id="二、定时器"><a href="#二、定时器" class="headerlink" title="二、定时器"></a>二、定时器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"><span class="comment"># 本质是一个线程，因为继承了Thread类，延迟一秒去执行</span></span><br></pre></td></tr></table></figure>

<p>具体应用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多长时间之后执行一个任务</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;我是大帅比--%s&#x27;</span>%name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># t = Timer(2, task,args=(&#x27;yang&#x27;,))  # 本质是开两个线程，延迟一秒执行</span></span><br><span class="line">    t = Timer(<span class="number">2</span>, task,kwargs=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;yang&#x27;</span>&#125;)  <span class="comment"># 本质是开两个线程，延迟一秒执行</span></span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><h3 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h3><p>面试几率极高</p>
<p>进程：资源分配的最小单位</p>
<p>线程：CPU调度的最小单位</p>
<p>协程：实现单线程下的并发，属于线程下</p>
<h3 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h3><p>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。</p>
<p>在一个线程中可能有很多的函数，比如函数1运行时遇到了io，此时协程把当前状态保存，切到函数2，当函数2遇到了io，又保存状态，再切其他函数</p>
<p>协程需要做到：保存状态+切换，这就能让人看起来是并发</p>
<p>我们利用yield来保存状态+切换。</p>
<p>yield：只要函数中有yield关键字，其返回值就是一个生成器。</p>
<p>如果是纯计算的多个函数，单纯的切换不但不会提高效率，反而会降低效率。</p>
<p>协程并不是真实存在的，而是程序员们臆想出来的。我们造出协程这个概念的目的，是因为cpu执行的线程的时候，遇到io就会跳到其他线程执行，那么我们现在当我们的线程遇到了io时候，直接跳到下一个函数去接着计算，如此不断的切函数。如此就伪装了我们这个线程一直在执行，没有遇到io，等到cpu的时间片到了，cpu才会去其他线程执行。</p>
<p>当协程没有利用好的话，会很大影响我们的效率，如函数A与B都阻塞了，但是我们还是在函数A与B中反复的切换，那么cpu的效率就被牺牲了。</p>
<h3 id="协程的优缺点（了解）"><a href="#协程的优缺点（了解）" class="headerlink" title="协程的优缺点（了解）"></a>协程的优缺点（了解）</h3><p>优点如下：</p>
<ol>
<li>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</li>
<li>单线程内就可以实现并发的效果，最大限度地利用cpu</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</li>
<li>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</li>
</ol>
<p>总结协程特点：</p>
<ol>
<li>必须在只有一个单线程里实现并发</li>
<li>修改共享数据不需加锁</li>
<li>用户程序里自己保存多个控制流的上下文栈</li>
<li>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））</li>
</ol>
<h2 id="四、greenlet模块（了解）"><a href="#四、greenlet模块（了解）" class="headerlink" title="四、greenlet模块（了解）"></a>四、greenlet模块（了解）</h2><p>上述的介绍的yield不是很好，现在介绍一个也不是很好的模块，greenlet，遇到io不会自动切。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 遇到io不会切，初级模块，gevent模块基于它写的，处理io切换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;我吃了一口&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    p.switch()</span><br><span class="line">    print(<span class="string">&#x27;我又吃了一口&#x27;</span>)</span><br><span class="line">    p.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;我玩了一会&#x27;</span>)</span><br><span class="line">    e.switch()</span><br><span class="line">    print(<span class="string">&#x27;我又玩了一会&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    e = greenlet(eat)</span><br><span class="line">    p = greenlet(play)</span><br><span class="line">    e.switch()</span><br></pre></td></tr></table></figure>



<h2 id="五、gevent模块"><a href="#五、gevent模块" class="headerlink" title="五、gevent模块"></a>五、gevent模块</h2><p>基于greenlet写的，实现了遇到了io自动切换</p>
<p>他开的不是线程，而是协程，为了实现单线程下实现并发。</p>
<p>猴子补丁，其实是一种替换的思想，拥有在模块运行时替换的功能，即动态替换</p>
<p>需要使用到猴子补丁，让我们本身的模块方法被替换成gevent模块下的方法，不然的话使用该模块就没有效果了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s 吃了一口&#x27;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># io操作，被猴子补丁替换之后，gevent.sleep()</span></span><br><span class="line">    print(<span class="string">&#x27;%s 又吃了一口&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s 玩了一会&#x27;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s 又玩了一会&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ctim = time.time()</span><br><span class="line">    e = gevent.spawn(eat,<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line">    p = gevent.spawn(play,<span class="string">&#x27;lqz&#x27;</span>)</span><br><span class="line">    e.join() <span class="comment"># 等待e执行完成</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line">    print(time.time() - ctim)  <span class="comment">#2.0165154933929443</span></span><br></pre></td></tr></table></figure>





<h2 id="六、asyncio（了解）"><a href="#六、asyncio（了解）" class="headerlink" title="六、asyncio（了解）"></a>六、asyncio（了解）</h2><p>官方支持的库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把普通函数变成协程函数</span></span><br><span class="line"><span class="comment"># 3.5以前这么写</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;开始了&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment">#asyncio.sleep(1)模拟io</span></span><br><span class="line">    print(<span class="string">&#x27;结束了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()  <span class="comment"># 获取一个时间循环对象#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 协程函数加括号，并不会真正的去执行，它需要提交给loop，让loop循环着去执行</span></span><br><span class="line"><span class="comment"># 协程函数列表</span></span><br><span class="line"></span><br><span class="line">ctime=time.time()</span><br><span class="line">t=[task(),task()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(t))</span><br><span class="line">loop.close()</span><br><span class="line">print(time.time()-ctime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.5以后</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="comment"># 表示我是协程函数,等同于3.5之前的装饰器</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;开始了&#x27;</span>)</span><br><span class="line">    print(current_thread().name)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># await等同于原来的yield from</span></span><br><span class="line">    print(<span class="string">&#x27;结束了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;开始了&#x27;</span>)</span><br><span class="line">    print(current_thread().name)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;结束了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">loop=asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">ctime=time.time()</span><br><span class="line">t=[task(),task2()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(t))</span><br><span class="line">loop.close()</span><br><span class="line">print(time.time()-ctime)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="七、io模型（面试重点）"><a href="#七、io模型（面试重点）" class="headerlink" title="七、io模型（面试重点）"></a>七、io模型（面试重点）</h2><h3 id="IO操作本质"><a href="#IO操作本质" class="headerlink" title="IO操作本质"></a>IO操作本质</h3><p>1.数据复制的过程中不会消耗CPU</p>
<p>2.内存分为内核缓冲区和用户缓冲区</p>
<p>3.应用程序不能直接操作内存缓冲区</p>
<p>3.各种资源包括网络下载的资源或者硬盘的资源加载到内存时候，先来到内核缓冲区，再copy到应用程序的缓冲区，应用程序才能用这个数据</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://tva1.sinaimg.cn/large/00831rSTly1gd8rw1pqm5j31700m2tdf.jpg" alt="image-20200325231658991"></p>
<h3 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h3><h4 id="阻塞io（BI-O）"><a href="#阻塞io（BI-O）" class="headerlink" title="阻塞io（BI/O）"></a>阻塞io（BI/O）</h4><p>在等待数据的时候，一直在等待，如果已经有数据，就等着从内核缓冲区复制到用户缓冲区，如果没数据，就等着cpu先去把数据获取到内核缓冲区，再等着数据从内核缓冲区复制到用户缓冲区。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">举个例子：一个人去 商店买一把菜刀，</span></span><br><span class="line"><span class="string">他到商店问老板有没有菜刀（发起系统调用）</span></span><br><span class="line"><span class="string">如果有（表示在内核缓冲区有需要的数据）</span></span><br><span class="line"><span class="string">老板直接把菜刀给买家（从内核缓冲区拷贝到用户缓冲区）</span></span><br><span class="line"><span class="string">这个过程买家一直在等待</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果没有，商店老板会向工厂下订单（IO操作，等待数据准备好）</span></span><br><span class="line"><span class="string">工厂把菜刀运给老板（进入到内核缓冲区）</span></span><br><span class="line"><span class="string">老板把菜刀给买家（从内核缓冲区拷贝到用户缓冲区）</span></span><br><span class="line"><span class="string">这个过程买家一直在等待</span></span><br><span class="line"><span class="string">是同步io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p><img src= "/img/loading.gif" data-lazy-src="Python-day40.assets/00831rSTly1gd8rw5x47nj318s0nwq9b.jpg" alt="image-20200325231903075"></p>
<h4 id="非阻塞io（NI-O）"><a href="#非阻塞io（NI-O）" class="headerlink" title="非阻塞io（NI/O）"></a>非阻塞io（NI/O）</h4><p>在等待数据的时候，可以切到其他地方运行。即如果此时没数据，就管自己做事情，且每隔一定时间发送询问是否有了数据。当多次询问后，数据已经到了内核缓冲区。那么就等着数据从内核缓冲区复制到用户缓冲区（此个过程就不能去做其他事情了）</p>
<p><img src= "/img/loading.gif" data-lazy-src="Python-day40.assets/00831rSTly1gd8rw9zwy9j317i0o6473.jpg" alt="image-20200325232410816"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">举个例子：一个人去 商店买一把菜刀，</span></span><br><span class="line"><span class="string">他到商店问老板有没有菜刀（发起系统调用）</span></span><br><span class="line"><span class="string">老板说没有，在向工厂进货（返回状态）</span></span><br><span class="line"><span class="string">买家去别地方玩了会，又回来问，菜刀到了么（发起系统调用）</span></span><br><span class="line"><span class="string">老板说还没有（返回状态）</span></span><br><span class="line"><span class="string">买家又去玩了会（不断轮询）</span></span><br><span class="line"><span class="string">最后一次再问，菜刀有了（数据准备好了）</span></span><br><span class="line"><span class="string">老板把菜刀递给买家（从内核缓冲区拷贝到用户缓冲区）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">整个过程轮询+等待：轮询时没有等待，可以做其他事，从内核缓冲区拷贝到用户缓冲区需要等待</span></span><br><span class="line"><span class="string">是同步io</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同一个线程，同一时刻只能监听一个socket，造成浪费，引入io多路复用，同时监听读个socket</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="io多路复用-Multiplexing-I-O"><a href="#io多路复用-Multiplexing-I-O" class="headerlink" title="io多路复用(Multiplexing - I/O)"></a>io多路复用(Multiplexing - I/O)</h4><p>目前使用最多是就是这个</p>
<p>是阻塞式io，阻塞在数据从内核缓冲区复制到用户缓冲区的地方，即这个过程还是得等待的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">举个例子：多个人去 一个商店买菜刀，</span></span><br><span class="line"><span class="string">多个人给老板打电话，说我要买菜刀（发起系统调用）</span></span><br><span class="line"><span class="string">老板把每个人都记录下来（放到select中）</span></span><br><span class="line"><span class="string">老板去工厂进货（IO操作）</span></span><br><span class="line"><span class="string">有货了，再挨个通知买到的人，来取刀（通知/返回可读条件）</span></span><br><span class="line"><span class="string">买家来到商店等待，老板把到给买家（从内核缓冲区拷贝到用户缓冲区）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多路复用：老板可以同时接受很多请求（select模型最大1024个，epoll模型），</span></span><br><span class="line"><span class="string">但是老板把到给买家这个过程，还需要等待，</span></span><br><span class="line"><span class="string">是同步io</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">​ <span class="number">1.</span> 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</span><br><span class="line">​ <span class="number">2.</span> 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</span><br><span class="line">​ 结论: select的优势在于可以处理多个连接，不适用于单个连接</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="Python-day40.assets/00831rSTly1gd8rwe9ouij31740nkwll.jpg" alt="image-20200325232430850"></p>
<h5 id="关于多路复用中的select-poll-epoll"><a href="#关于多路复用中的select-poll-epoll" class="headerlink" title="关于多路复用中的select,poll,epoll"></a>关于多路复用中的select,poll,epoll</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 select poll 和epoll都是io多路复用技术</span></span><br><span class="line">select, poll , epoN都是io多路复用的机制。I/O多路复用就是通过一种机 制个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select, poll , epoll本质上都是同步I/O ,因为他们都需要在读写事件就绪后自己负责进行读写， 也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异 步I/O的实现会负责把数据从内核拷贝到用户空间。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 select</span></span><br><span class="line">select函数监视的文件描述符分<span class="number">3</span>类，分别是writefds、readfds、和 exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据可读、 可写、或者有<span class="keyword">except</span>）,或者超时（timeout指定等待时间，如果立即返回 设为null即可），函数返回。当select函数返回后，可以通过遍历fdset,来 找到就绪的描述符。</span><br><span class="line">select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个 优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为<span class="number">1024</span> ,可以通过修改宏定义甚至重新编译内核的 方式提升这一限制，但是这样也会造成效率的降低。</span><br><span class="line"><span class="comment"># 3 poll</span></span><br><span class="line">不同于select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</span><br><span class="line">pollfd结构包含了要监视的event和发生的event,不再使用select <span class="string">&#x27;参数-值&#x27;</span>传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后 性能也是会下降）。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</span><br><span class="line">从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取 已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 epoll</span></span><br><span class="line">epoll是在linux2<span class="number">.6</span>内核中提出的，是之前的select和poll的增强版本。相对 于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文 件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 更好的例子理解</span></span><br><span class="line">老师检查同学作业，一班<span class="number">50</span>个人，一个一个问，同学，作业写完了没？select，poll</span><br><span class="line">老师检查同学作业，一班<span class="number">50</span>个人，同学写完了主动举手告诉老师，老师去检查 epoll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 总结</span></span><br><span class="line">在并发高的情况下，连接活跃度不高，epoll比select好，网站http的请求，连了就断掉</span><br><span class="line">并发性不高，同时连接很活跃，select比epoll好，websocket的连接，长连接，游戏开发</span><br></pre></td></tr></table></figure>



<p>select（windows支持，windows不支持epoll，官方不提供redis的window版本），poll（linux支持），epoll（linux支持）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本部分为了解内容，感兴趣可看</span></span><br><span class="line">IO复用：为了解释这个名词，首先来理解下复用这个概念，复用也就是共用的意思，这样理解还是有些抽象，为此，咱们来理解下复用在通信领域的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或频分复用的技术使其在同一链路上传输多路信号，到这里我们就基本上理解了复用的含义，即公用某个“介质”来尽可能多的做同一类(性质)的事，那IO复用的“介质”是什么呢？为此我们首先来看看服务器编程的模型，客户端发来的请求服务端会产生一个进程来对其进行服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了IO复用技术，即：一个进程可以同时对多个客户请求进行服务。也就是说IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">理解完IO复用后，我们在来看下实现IO复用中的三个API(select、poll和epoll)的区别和联系</span><br><span class="line"></span><br><span class="line">select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：</span><br><span class="line"></span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1.</span>select的第一个参数nfds为fdset集合中最大描述符值加<span class="number">1</span>，fdset是一个位数组，其大小限制为__FD_SETSIZE（<span class="number">1024</span>），位数组的每一位代表其对应的描述符是否需要被检查。第二三四参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件，所以每次调用select前都需要重新初始化fdset。timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。</span><br><span class="line"></span><br><span class="line"> select的调用步骤如下：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）使用copy_from_user从用户空间拷贝fdset到内核空间</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）注册回调函数__pollwait</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</span><br><span class="line"></span><br><span class="line">（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll 来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数 据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）把fd_set从内核空间拷贝到用户空间。</span><br><span class="line"></span><br><span class="line">总结下select的几大缺点：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）select支持的文件描述符数量太小了，默认是<span class="number">1024</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>．  poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</span><br><span class="line"></span><br><span class="line"> poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>．直到Linux2<span class="number">.6</span>才出现了由内核直接支持的实现方法，那就是epoll，被公认为Linux2<span class="number">.6</span>下性能最好的多路I/O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll 和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函 数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注 册要监听的事件类型；epoll_wait则是等待事件的产生。</span><br><span class="line"></span><br><span class="line">　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定 EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝 一次。</span><br><span class="line"></span><br><span class="line">　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在 epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调 函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用 schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第<span class="number">7</span>步是类似的）。</span><br><span class="line"></span><br><span class="line">　　对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于<span class="number">2048</span>,举个例子, 在<span class="number">1</span>GB内存的机器上大约是<span class="number">10</span>万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销。</span><br><span class="line"><span class="comment">###############</span></span><br><span class="line">这三种IO多路复用模型在不同的平台有着不同的支持，而epoll在windows下就不支持，好在我们有selectors模块，帮我们默认选择当前平台下最合适的</span><br><span class="line"><span class="comment">##############</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"></span><br><span class="line">sel=selectors.DefaultSelector()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">server_fileobj,mask</span>):</span></span><br><span class="line">    conn,addr=server_fileobj.accept()</span><br><span class="line">    sel.register(conn,selectors.EVENT_READ,read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn,mask</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">&#x27;closing&#x27;</span>,conn)</span><br><span class="line">            sel.unregister(conn)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        conn.send(data.upper()+<span class="string">b&#x27;_SB&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">&#x27;closing&#x27;</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">server_fileobj=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">server_fileobj.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">server_fileobj.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8088</span>))</span><br><span class="line">server_fileobj.listen(<span class="number">5</span>)</span><br><span class="line">server_fileobj.setblocking(<span class="literal">False</span>) <span class="comment">#设置socket的接口为非阻塞</span></span><br><span class="line">sel.register(server_fileobj,selectors.EVENT_READ,accept) <span class="comment">#相当于网select的读列表里append了一个文件句柄server_fileobj,并且绑定了一个回调函数accept</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events=sel.select() <span class="comment">#检测所有的fileobj，是否有完成wait data的</span></span><br><span class="line">    <span class="keyword">for</span> sel_obj,mask <span class="keyword">in</span> events:</span><br><span class="line">        callback=sel_obj.data <span class="comment">#callback=accpet</span></span><br><span class="line">        callback(sel_obj.fileobj,mask) <span class="comment">#accpet(server_fileobj,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">c=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">c.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8088</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line">    c.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data=c.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="异步io（AI-O）"><a href="#异步io（AI-O）" class="headerlink" title="异步io（AI/O）"></a>异步io（AI/O）</h4><p>发起请求立刻得到回复，不用挂起等待； 数据会由内核进程主动完成拷贝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">举个例子：还是买菜刀</span></span><br><span class="line"><span class="string">现在是网上下单到商店（系统调用）</span></span><br><span class="line"><span class="string">商店确认（返回）</span></span><br><span class="line"><span class="string">商店去进货（io操作）</span></span><br><span class="line"><span class="string">商店收到货把货发个卖家（从内核缓冲区拷贝到用户缓冲区）</span></span><br><span class="line"><span class="string">买家收到货（指定信号）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">整个过程无等待</span></span><br><span class="line"><span class="string">异步io</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">市面上多数的高并发框架，都没有使用异步io而是用的io多路复用，因为io多路复用技术很成熟且稳定，并且在实际的使用过程中，异步io并没有比io多路复用性能提升很多，没有达到很明显的程度</span></span><br><span class="line"><span class="string">并且，真正的AIO编码难度比io多路复用高很多</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="Python-day40.assets/00831rSTly1gd8rwiz5grj318c0pgn3u.jpg" alt="image-20200325232454769"></p>
<h4 id="信号驱动io"><a href="#信号驱动io" class="headerlink" title="信号驱动io"></a>信号驱动io</h4><p>目前还在理论阶段，不做讨论</p>
<h3 id="同步I-O与异步I-O"><a href="#同步I-O与异步I-O" class="headerlink" title="同步I/O与异步I/O"></a>同步I/O与异步I/O</h3><ul>
<li>同步I/O<ul>
<li>概念：导致请求进程阻塞的I/O操作，直到I/O操作任务完成</li>
<li>类型：BIO、NIO、IO Multiplexing</li>
</ul>
</li>
<li>异步I/O<ul>
<li>概念：不导致进程阻塞的I/O操作</li>
<li>类型：AIO</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>同步I/O与异步I/O判断依据是，是否会导致用户进程阻塞</li>
<li>BIO中socket直接阻塞等待（用户进程主动等待，并在拷贝时也等待）</li>
<li>NIO中将数据从内核空间拷贝到用户空间时阻塞（用户进程主动询问，并在拷贝时等待）</li>
<li>IO Multiplexing中select等函数为阻塞、拷贝数据时也阻塞（用户进程主动等待，并在拷贝时也等待）</li>
<li>AIO中从始至终用户进程都没有阻塞（用户进程是被动的）</li>
</ul>
<h2 id="八、并发-并行-同步-异步-阻塞-非阻塞"><a href="#八、并发-并行-同步-异步-阻塞-非阻塞" class="headerlink" title="八、并发-并行-同步-异步-阻塞-非阻塞"></a>八、并发-并行-同步-异步-阻塞-非阻塞</h2><p>1 并发<br>并发是指一个时间段内，有几个程序在同一个cpu上执行，但是同一时刻，只有一个程序在cpu上运行<br>跑步，鞋带开了，停下跑步，系鞋带<br>2 并行<br>指任意时刻点上，有多个程序同时运行在多个cpu上<br>跑步，边跑步边听音乐<br>3 同步：<br>指代码调用io操作时，必须等待io操作完成才返回的调用方式<br>4 异步<br>异步是指代码调用io操作时，不必等io操作完成就返回调用方式<br>5 阻塞<br>指调用函数时候，当前线程别挂起<br>6 非阻塞<br>指调用函数时候，当前线程不会被挂起，而是立即返回</p>
<p>区别：<br>同步和异步是消息通讯的机制<br>阻塞和非阻塞是函数调用机制</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">王寄鱼</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/27/Python-day40-%E5%8D%8F%E7%A8%8B/">http://yoursite.com/2020/08/27/Python-day40-%E5%8D%8F%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">王寄鱼's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/29/Python-day41-%E5%BE%80%E6%9C%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"><img class="prev-cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python day41:往期知识回顾</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/26/Python-day39-%E7%BA%BF%E7%A8%8B2/"><img class="next-cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python day39:线程2</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/11/Python-day1-计算机硬件基础/" title="Python day1:计算机硬件基础"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day1:计算机硬件基础</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/11/Python-day10-文件处理/" title="Python day10:文件处理"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day10:文件处理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/11/Python-day11-文件处理2/" title="Python day11:文件处理2"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day11:文件处理2</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/11/Python-day13-函数基础2/" title="Python day13:函数基础2"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day13:函数基础2</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/11/Python-day14-闭包函数与装饰器/" title="Python day14:闭包函数与装饰器"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day14:闭包函数与装饰器</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/11/Python-day12-文件处理3+函数基础/" title="Python day12:文件处理3+函数基础"><img class="relatedPosts_cover" data-lazy-src="https://s1.ax1x.com/2020/08/09/a7SlNt.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-11</div><div class="relatedPosts_title">Python day12:文件处理3+函数基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://s1.ax1x.com/2020/08/09/a7SlNt.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 王寄鱼</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">逆水行舟,不进则退</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'mhNShr1CKGIKtmIJFxImG6CR-gzGzoHsz',
      appKey: 'CUz06D7chSo4N0TpK8yCqlBh',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/ClickShowText.js" async="async"></script></div><script type="text/javascript" src="/js/FunnyTitle.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>